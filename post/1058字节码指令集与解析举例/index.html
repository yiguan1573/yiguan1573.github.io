<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="referrer" content="never">

    
    <meta property="og:site_name" content="亿观的博客">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://yiguan1573.github.io//img/01.jpg">
    <meta property="twitter:image" content="https://yiguan1573.github.io//img/01.jpg" />
    

    
    <meta name="title" content="18、字节码指令集与解析举例（JVM）" />
    <meta property="og:title" content="18、字节码指令集与解析举例（JVM）" />
    <meta property="twitter:title" content="18、字节码指令集与解析举例（JVM）" />
    

    
    <meta name="description" content="">
    <meta property="og:description" content="" />
    <meta property="twitter:description" content="" />
    

    
    <meta property="twitter:card" content="summary" />
    
    

    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>18、字节码指令集与解析举例（JVM） | yiguan1573</title>

    <link rel="canonical" href="/post/1058%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/">

    
    
    
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/css/zanshang.css">

    
    <link href="https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css" rel="stylesheet" type="text/css">

    
    

    
    <script src="/js/jquery.min.js"></script>

    
    <script src="/js/bootstrap.min.js"></script>

    
    <script src="/js/hux-blog.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">亿观的博客</a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">首页</a>
                    </li>
                    
                        
                        <li>
                            <a href="/categories/%E5%AD%A6%E4%B9%A0">学习</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/top/archive/">档案</a></li>
                    
                        <li><a href="/top/about/">关于</a></li>
                    

                    
		    <li>
                        <a href="/search"><i class="fa fa-search"></i></a>
		    </li>
                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>




<style type="text/css">
    header.intro-header {
        background-image: url('/img/03.JPG')
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/jvm" title="JVM">
                            JVM
                        </a>
                        
                    </div>
                    <h1>18、字节码指令集与解析举例（JVM）</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        
                            Posted by 
                            
                                亿观
                             
                            on 
                            Friday, September 2, 2022
                            
                                <span id="/post/1058%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%B8%BE%E4%BE%8B/" class="leancloud_visitors meta_data_item" data-flag-title="">
    <span class="post-meta-item-icon">
      <span class="octicon octicon-eye"></span> 
    </span>
    <i class="fa fa-eye"></i>
    <span class="old-visitors-count" style="display: none;"></span>
    <span class="leancloud-visitors-count"></span>
</span>



<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>

<script>
	AV.initialize("", "");
</script>

<script type="text/javascript">
function showTime(Counter) {
    var query = new AV.Query(Counter);
    var entries = [];
    var $visitors = $(".leancloud_visitors");

    $visitors.each(function() {
        entries.push($(this).attr("id").trim());
    });

    query.containedIn('url', entries);
    query.find()
        .done(function(results) {
            var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
            var OLD_COUNT_CONTAINER_REF = '.old-visitors-count';

            
            
            
            

            for (var i = 0; i < results.length; i++) {
                var item = results[i];
                var url = item.get('url');
                var time = item.get('time');
                var element = document.getElementById(url);

                $(element).find(COUNT_CONTAINER_REF).text(time);
            }
            for (var i = 0; i < entries.length; i++) {
                var url = entries[i];
                var element = document.getElementById(url);
                var countSpan = $(element).find(COUNT_CONTAINER_REF);
                if (countSpan.text() == '') {
                    var oldCountSpan = $(element).find(OLD_COUNT_CONTAINER_REF).text();
                    if(oldCountSpan!=''){
                        countSpan.text(0+parseInt(oldCountSpan));
                    }else{
                        countSpan.text(0);          
                    }
                }
            }
        })
        .fail(function(object, error) {
            console.log("Error: " + error.code + " " + error.message);
        });
}

function addCount(Counter) {
    var $visitors = $(".leancloud_visitors");
    var url = $visitors.attr('id').trim();
    var title = $visitors.attr('data-flag-title').trim();
    var query = new AV.Query(Counter);

    query.equalTo("url", url);
    query.find({
        success: function(results) {
            if (results.length > 0) {
                var counter = results[0];
                counter.fetchWhenSave(true);
                counter.increment("time");
                counter.save(null, {
                    success: function(counter) {
                        var $element = $(document.getElementById(url));
                        $element.find('.leancloud-visitors-count').text(counter.get('time'));
                    },
                    error: function(counter, error) {
                        console.log('Failed to save Visitor num, with error message: ' + error.message);
                    }
                });
            } else {
                var newcounter = new Counter();
                 
                var acl = new AV.ACL();
                acl.setPublicReadAccess(true);
                acl.setPublicWriteAccess(true);
                newcounter.setACL(acl);
                 
                newcounter.set("title", title);
                newcounter.set("url", url);
                var OLD_COUNT_CONTAINER_REF = '.old-visitors-count';
                var $element = $(document.getElementById(url));
                var oldCountSpan = $element.find(OLD_COUNT_CONTAINER_REF).text();
                if(oldCountSpan!=''){
                    newcounter.set("time", parseInt(oldCountSpan)+1);
                }else{
 	                    newcounter.set("time",  1);
                }
                newcounter.save(null, {
                    success: function(newcounter) {
                        var $element = $(document.getElementById(url));
                        $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
                    },
                    error: function(newcounter, error) {
                        console.log('Failed to create');
                    }
                });
            }
        },
        error: function(error) {
            console.log('Error:' + error.code + " " + error.message);
        }
    });
}
$(function() {
    var Counter = AV.Object.extend("Counter");
    
    
    if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
    } else {
        showTime(Counter);
    }
});
</script>

                            
                            
                            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>




<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                <blockquote>
<p>这章主要是方法体的内容，即Code属性</p>
</blockquote>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dm9czysj30wg0g5jsi.jpg" alt="QQ截图20220913230532.jpg">

</p>
<h2 id="概述">概述</h2>
<ul>
<li>
<p>Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行命令。</p>
</li>
<li>
<p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为 <strong>操作码，Opcode</strong> )以及跟随其后的零至多个代表此操作所需参数(称为 <strong>操作数，Operands</strong> )而构成，由于 Java 虚拟机采用面向操作数栈而不是寄存器的结构，所以大多数的指令都不包含操作数，只有一个操作码。</p>
</li>
<li>
<p>由于限制了 Java 虚拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不可能超过256条。（2^8=256）</p>
</li>
<li>
<p>官方文档：<a href="https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p>
</li>
<li>
<p>熟悉虚拟机的指令对于动态字节码生成、反编译 Class 文件、 Class 文件修补都有着非常重要的价值。因此，阅读字节码作为了解 Java 虚拟机的基础技能，需要熟练掌握常见指令。</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dnb6xxxj30os0m7k4k.jpg" alt="image-20201224080527376.png">

</p>
</li>
</ul>
<h3 id="执行模型">执行模型</h3>
<ul>
<li>
<p>如果不考虑异常处理的话，那么 Java 虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">do</span> <span style="color:#ff79c6">{</span>
    自动计算PC寄存器的值加1<span style="color:#ff79c6">;</span>
    根据PC寄存器的指示位置，从字节码流中取出操作码<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">if</span><span style="color:#ff79c6">(</span>字节码存在操作数<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        从字节码流中取出操作数<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
    执行操作码所定义的操作<span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span><span style="color:#ff79c6">while</span><span style="color:#ff79c6">(</span>字节码长度<span style="color:#ff79c6">&gt;</span>0<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>  <span style="color:#6272a4">// 字节码长度大于0，则一直循环执行
</span></code></pre></div></li>
</ul>
<h3 id="字节码与数据类型">字节码与数据类型</h3>
<ul>
<li>在 Java 虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload 指令用于从局部变量表中加载 int 类型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。</li>
<li>对于大部分与数据类型相关的字节码指令，<strong>它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</strong>
<ul>
<li>i 代表对 int 类型的数据操作</li>
<li>l 代表 long</li>
<li>s 代表 short</li>
<li>b 代表 byte</li>
<li>c 代表 char</li>
<li>f 代表 float</li>
<li>d 代表 double</li>
</ul>
</li>
</ul>
<ul>
<li>也有一些指令的助记符中 <strong>没有明确地指明操作类型的字母</strong> ，如 arraylength 指令（获取数组对象的长度的指令），它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</li>
</ul>
<ul>
<li>
<p>还有另一些指令，如无条件跳转指令 goto 则是与 <strong>数据类型无关的</strong> 。</p>
</li>
<li>
<p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。编译器会在编译器或运行期将 byte 和short 类型的数据带符号扩展(Sign-Extend)为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展(Zero-Extend)为相应的 int 类型数据。与之类似，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 init 类型的字节码指令来处理。因此，大多数对于 boolean、byte、short 和 char 类型数据的操作，实际上都是使用相应的 int 类型作为运算类型。</p>
</li>
<li>
<p>a是对象类型</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dq6z30bj30fv07c0sx.jpg" alt="QQ截图20220913230919.jpg">

</p>
</li>
<li>
<p>整数所占槽位</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dqxwiioj30zm0er3za.jpg" alt="QQ截图20220913230953.jpg">

</p>
</li>
</ul>
<h3 id="指令分类">指令分类</h3>
<ul>
<li>由于完全介绍和学习这些指令需要花费大量时间，为了让能够更快地熟悉和了解这些基本指令，这里将 JVM 中的字节码指令集按用途大致分成9类：
<ul>
<li>加载与存储指令</li>
<li>算术指令</li>
<li>类型转换指令</li>
<li>对象的创建与访问指令</li>
<li>方法调用与返回指令</li>
<li>操作数栈管理指令</li>
<li>比较控制指令</li>
<li>异常处理指令</li>
<li>同步控制指令</li>
</ul>
</li>
</ul>
<ul>
<li>在做值相关操作时
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用等中取得数据，这些数据(可能是值，可能是对象的引用)被压入操作数栈。</li>
<li>一个指令，也可以从操作数栈中取出一到多个值(pop 多次)，完成赋值、加减乘除、方法传参、系统调用等操作。</li>
</ul>
</li>
</ul>
<h2 id="加载与存储指令">加载与存储指令</h2>
<ul>
<li>
<p>作用：加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</p>
</li>
<li>
<p>常用指令</p>
<ul>
<li>【局部变量压栈指令】将一个局部变量加载到操作数栈：<code>xload、xload_n</code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>)（比如iload_0、lload_1、aload_3，因为0-3的操作次数比较多，所以就预先定义好了，4以上就要自己定义，就没有下划线，比如iload 4）。</li>
</ul>
<ul>
<li>【常量入栈指令】将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、iconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code>。</li>
<li>【出栈装入局部变量表指令】将一个数值从操作数栈存储到局部变量表：<code>xstore、xstore_&lt;n&gt;</code>(<code>其中 x 为 i、l、f、d、a，n 为 0 到 3</code>);  <code>xastore</code>(<code>其中 x 为 i、l、f、d、a、b、c、s</code>)。</li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code>。</li>
</ul>
</li>
</ul>
<ul>
<li>小结：load、push、ldc、const都是压栈到操作数栈中，store是保存数据到局部变量表中</li>
<li>上面所列举的指令助记符中，有一部分是以尖括号结尾的(例如 <code>iload_&lt;n&gt;</code>)。这些指令助记符实际上代表了一组指令(例如 <code>iload_&lt;n&gt;</code>代表了 <code>iload_0、iload_1、iload_2和iload_3</code>这几个指令)。这几组指令都是某个带有一个操作数的通用指令(例如 <code>iload</code>)的特殊形式，<strong>对于这若干组特殊指令来说，它们表面上没有操作数，不需要进行取操作数的动作，但操作数都隐含在指令中</strong></li>
<li>除此之外，它们的语义与原生的通用指令完全一致(例如 <code>iload_0</code>的语义与操作数为0时的 <code>iload</code>指令语义完全一致)。在尖括号之间的字母指定了指令隐含操作数的数据类型，代表非负的整数，<em>代表是 int 类型数据，代表 long 类型，代表 float 类型，代表 double 类型。</em></li>
<li><em>操作 byte、char、short 和 boolean 类型数据时，经常用 int 类型的指令来表示。</em></li>
<li><em>例子：</em>
<ul>
<li>
<p><em>iload_0：将局部变量表中索引为0位置上的数据压入操作数栈中；（iload_0与iload 0是一样的，区别在于iload 0占用3个字节，操作码1个字节码，操作数2个字节，而iload_0只占用1个字节，所以iload_0更节省空间。）</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dwip25pj30qn0hzqaw.jpg" alt="image-20201225075659722.png">

</p>
</li>
</ul>
</li>
</ul>
<h3 id="复习再谈操作数栈与局部变量表">复习：再谈操作数栈与局部变量表</h3>
<h4 id="操作数栈operand-stacks">操作数栈(Operand Stacks)</h4>
<p><em>我们知道，Java 字节码是 Java 虚拟机所使用的指令集。因此，它与 Java 虚拟机基于栈的计算模型是密不可分的。</em></p>
<p><em>在解释执行过程中，每当为 Java 方法分配栈帧时，Java 虚拟机往往需要 <strong>开辟一块额外的空间作为操作数栈，来存放计算的操作数以及返回结果</strong> 。</em></p>
<p><em>具体来说便是： <strong>执行每一条指令之前，Java 虚拟机要求该指令的操作数已被压入操作数栈中。在执行指令时，Java 虚拟机会将该指令所需的操作数弹出，并且将指令的结果重新压入栈中</strong> 。</em></p>
<p><em>以加法指令 iadd 为例。假设在执行该指令之前，栈顶的两个元素分别为 int 值 1 和 int 值 2，那么 iadd 指令将弹出这两个 int（由于 iadd 指令只消耗栈顶的两个元素，因此，对于离栈顶距离为 2 的元素，即图中的问号，iadd 指令并不关心它是否存在，更加不会对其进行修改），并将求得的和 int 值为 3 压入栈中。</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h65dxyf95mj30oo0anmxl.jpg" alt="QQ截图20220913231648.jpg">

</p>
<h4 id="局部变量表local-variables">局部变量表(Local Variables)</h4>
<ul>
<li>
<p><em>Java 方法栈帧的另外一个重要组成部分则是局部变量区， <strong>字节码程序可以将计算的结果缓存在局部变量区之中</strong> 。</em></p>
</li>
<li>
<p><em>实际上，Java 虚拟机将局部变量区当成 <strong>一个数组</strong> ，依次存放 this 指针(仅非静态方法)，所传入的参数，以及字节码中的局部变量。</em></p>
</li>
<li>
<p><em>和操作数栈一样，long 类型以及 double 类型的值将占据两个单元，其余类型仅占据一个单元。</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">foo</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">long</span> l<span style="color:#ff79c6">,</span> <span style="color:#8be9fd">float</span> f<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
  <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span>
  <span style="color:#ff79c6">}</span>
  <span style="color:#ff79c6">{</span>
    String s <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;Hello, World&#34;</span>
  <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66fy1bdwuj30wi04ldg0.jpg" alt="QQ截图20220914211124.jpg">

</p>
</li>
<li>
<p><em>在栈帧中，与性能调优关系最为密切的部分就是局部变量表。局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。</em></p>
</li>
<li>
<p><em>在方法执行时，虚拟机使用局部变量表完成方法的传递。</em></p>
</li>
</ul>
<h3 id="局部变量压栈指令">局部变量压栈指令</h3>
<ul>
<li><em>局部变量压栈指令将给定的局部变量表中的数据压入操作数栈。</em></li>
<li><em>这类指令大体可以分为：</em>
<ul>
<li><em><code>xload_&lt;n&gt;</code>(<code>x</code>为 <code>i、l、f、d、a，n为 0 到 3</code>)</em></li>
<li><em><code>xload</code>(<code>x</code>为 <code>i、l、f、d、a</code>)</em></li>
</ul>
</li>
</ul>
<ul>
<li>
<p><em>说明：在这里，x的取值表示数据类型，n为局部变量表的索引值。</em></p>
</li>
<li>
<p><em>指令 <code>xload_n</code>表示将第n个局部变量压入操作数栈，比如 <code>iload_1、fload_0、aload_0</code>等指令。其中 <code>aload_n</code>表示将一个对象引用压栈。</em></p>
</li>
<li>
<p><em>指令 <code>xload</code>通过指定参数的形式，把局部变量压入操作数栈，当使用这个命令时，表示局部变量的数量可能超过了4个，比如指令 <code>iload、fload</code>等</em></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#ff79c6">import</span> java.util.Date<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_07_LoadAndStoreTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">// 1.局部变量压栈指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">load</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> num<span style="color:#ff79c6">,</span> Object obj<span style="color:#ff79c6">,</span><span style="color:#8be9fd">long</span> count<span style="color:#ff79c6">,</span><span style="color:#8be9fd">boolean</span> flag<span style="color:#ff79c6">,</span><span style="color:#8be9fd">short</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> arr<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>num<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>obj<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>count<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>flag<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>arr<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#6272a4">// 2.常量入栈指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">pushConstLdc</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>1<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> 5<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> b <span style="color:#ff79c6">=</span> 6<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> 127<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> d <span style="color:#ff79c6">=</span> 128<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> e <span style="color:#ff79c6">=</span> 32767<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> f <span style="color:#ff79c6">=</span> 32768<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">constLdc</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">long</span> a1 <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">long</span> a2 <span style="color:#ff79c6">=</span> 2<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">float</span> b1 <span style="color:#ff79c6">=</span> 2<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">float</span> b2 <span style="color:#ff79c6">=</span> 3<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">double</span> c1 <span style="color:#ff79c6">=</span> 1<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">double</span> c2 <span style="color:#ff79c6">=</span> 2<span style="color:#ff79c6">;</span>
        Date d <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">null</span><span style="color:#ff79c6">;</span>

    <span style="color:#ff79c6">}</span>

    <span style="color:#6272a4">// 3.出栈装入局部变量表指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">store</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> k<span style="color:#ff79c6">,</span> <span style="color:#8be9fd">double</span> d<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> m <span style="color:#ff79c6">=</span> k <span style="color:#ff79c6">+</span> 2<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">long</span> l <span style="color:#ff79c6">=</span> 12<span style="color:#ff79c6">;</span>
        String str <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;atguigu&#34;</span><span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">float</span> f <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">.</span><span style="color:#50fa7b">0F</span><span style="color:#ff79c6">;</span>
        d <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">foo</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">long</span> l<span style="color:#ff79c6">,</span> <span style="color:#8be9fd">float</span> f<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">{</span>
            <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
        <span style="color:#ff79c6">{</span>
            String s <span style="color:#ff79c6">=</span> <span style="color:#f1fa8c">&#34;Hello, World&#34;</span><span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">}</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div></li>
<li>
<p><em>分析load方法的字节指令</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66g2be12tj30p00ofgum.jpg" alt="image-20201227095459865.png">

</p>
</li>
<li>
<p><em>局部变量表</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66g2nt72dj31b20kgqn6.jpg" alt="image-20201227095938223.png">

</p>
</li>
<li>
<p><em>字节指令执行过程iload_1</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66g36t7pdj312r0grtmw.jpg" alt="image-20201227100835651.png">

</p>
</li>
<li>
<p><em>除了iload 5不一样，其他load指令同理</em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66g3lik86j31200gttnh.jpg" alt="image-20201227101520671.png">

</p>
</li>
</ul>
<h3 id="常量入栈指令">常量入栈指令</h3>
<ul>
<li><em>常量入栈指令的功能是将常数压入操作数栈，根据数据类型和入栈内容的不同，又可以分为 const 系列、push 系列和 ldc 指令（这个三个指令范围依次变大）。</em></li>
</ul>
<ul>
<li>
<p><strong>指令 const 系列：</strong> 用于对特定的常量入栈，入栈的常量隐含在指令本身里。指令有：<code>iconst_&lt;i&gt;(i从-1到5)、lconst_&lt;l&gt;(l从0到1)、fconst_&lt;f&gt;(f从0到2)、dconst_&lt;d&gt;(d从0到1)、aconst_null</code>（注意，这里的、、、的取值都是指具体的常量值，不是“局部变量压栈指令”那样的索引值；引用类型，都有一个默认的null值）。</p>
</li>
<li>
<p><strong>比如：</strong></p>
<ul>
<li><strong>iconst_m1将-1压入操作数栈（m1就是-1，m是minus的缩写）</strong></li>
<li><strong>iconst_x(x为0到5)将 x 压入栈</strong></li>
<li><strong>lconst_0、lconst_1 分别将长整数0和1压入栈</strong></li>
<li><strong>fconst_0、fconst_1、fconst_2 分别将浮点数0、1、2压入栈</strong></li>
<li><strong>dconst_0 和 dconst_1 分别将 double 型0和1压入栈</strong></li>
<li><strong>aconst_null 将 null 压入操作数</strong></li>
</ul>
</li>
<li>
<p><strong>从指令的命名上不难找出规律，指令助记符的第一个字符总是喜欢表示数据类型，i 表示整数，l 表示长整型，f 表示浮点数，d 表示双精度浮点，习惯上用 a 表示对象引用。如果指令隐含操作的参数，会以下划线形式给出。</strong></p>
<pre><code>Java代码： int i = 3;  --&gt;  对应的字节码指令：iconst_3
Java代码： int j = 6;  --&gt;  对应的字节码指令：不是iconst 6，因为iconst只能操作-1到5的数，而是bipush 6
</code></pre></li>
</ul>
<ul>
<li>
<p><strong>指令 push 系列：</strong> 主要包括 bipush 和 sipush。它们的区别在于接受数据类型的不同，bipush 接收8位（1字节）整数作为参数，sipush 接收16位（2字节）整数，它们都将参数压入栈。</p>
</li>
<li>
<p><strong><strong>指令 ldc 系列：</strong> 如果以上指令都不能满足需求，那么可以使用万能的 <strong>ldc</strong> 指令，它可以接收一个8位的参数，该参数指向常量池中的 int、float 或者 String 的索引（ldc操作的常量值会从常量池获取的，与其他指令直接操作具体的常量值不同），将指定的内容压入堆栈。</strong></p>
</li>
<li>
<p><strong>类似的还有  <strong>ldc_w</strong> ，它接收两个8位参数，能支持的索引范围大于 ldc。</strong></p>
</li>
<li>
<p><strong>如果要压入的元素是 long 或者 double 类型的，则使用 <strong>ldc2_w</strong> 指令，使用方式都是类似的</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66g9xab3yj30rr0hrn31.jpg" alt="image-20201227103924096.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ga4pk3bj30w00mjqis.jpg" alt="image-20201227104949674.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gabhf7aj310q0i4n7q.jpg" alt="image-20201227105604823.png">

</p>
</li>
</ul>
<h3 id="出栈装入局部变量表指令">出栈装入局部变量表指令</h3>
<ul>
<li><strong>出栈装入局部变量表指令用于将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值。</strong></li>
<li><strong>这类指令主要以 store 的形式存在，比如 <code>xstore(x 为 i、l、f、d、a)、xstore_n(x 为 i、l、f、d、a，n 为0至3)</code></strong>
<ul>
<li><strong>其中，指令 istore_n 将从操作数栈中弹出一个整数，并把它赋值给局部变量表中索引为n的位置（n表示索引，与load指令类似）。</strong></li>
<li><strong>指令 xstore 由于没有隐含参数信息，故需要提供一个 byte 类型的参数类指定目标局部变量表的位置。</strong></li>
</ul>
</li>
<li><strong>说明：</strong>
<ul>
<li>
<p><strong><strong>一般说来，类似像 store 这样的命令需要带一个参数，用来指明将弹出的元素放在局部变量表的第几个位置</strong> 。但是，为了尽可能压缩指令大小，使用专门的 istore_1 指令表示将弹出的元素放置在局部变量表第1个位置。类似的还有 istore_0、istore_2、istore_3，它们分别表示从操作数栈顶弹出一个元素，存放在局部变量表第0、2、3个位置.</strong></p>
</li>
<li>
<p><strong>由于局部变量表前几个位置总是非常常用，因此 <strong>这种做法虽然增加了指令数量，但是可以大大压缩生成的字节码的体积</strong> 。如果局部变量表很大，需要存储的槽位大于3，那么可以使用 istore 指令，外加一个参数，用来表示需要存放的槽位位置</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gv1rvaxj318b0h7dsb.jpg" alt="image-20201227111332985.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gvf1ghij31910h4n8l.jpg" alt="image-20201227111444341.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gvoh8dgj312q0fzakk.jpg" alt="image-20201227111525913.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gvx1xolj318a0id4ej.jpg" alt="image-20201227112100285.png">

</p>
</li>
<li>
<p><strong>有个需要注意的地方</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gw2itdxj312g0l34b7.jpg" alt="image-20201227114052698.png">

</p>
</li>
</ul>
</li>
</ul>
<h3 id="总结">总结</h3>
<ul>
<li><strong>load是局部变量压入操作数栈；</strong></li>
<li><strong>const是常量压入操作数栈；</strong></li>
<li><strong>store是操作数栈的栈顶出栈装入局部变量。</strong></li>
</ul>
<h2 id="算术指令">算术指令</h2>
<p><strong><strong>1、作用</strong></strong></p>
<p><strong>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新压入操作数栈。</strong></p>
<p><strong><strong>2、分类</strong></strong></p>
<p><strong>大体上算术指令可以分为两种：对</strong>整型数据<strong>进行运算的指令与对</strong>浮点型类型数据<strong>进行运算的指令。</strong></p>
<p><strong><strong>3、byte、short、char 和 boolean 类型说明</strong></strong></p>
<p><strong>在每一大类中，都有针对 Java 虚拟机具体数据类型的专用算术指令。但没有直接支持 byte、short、char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理。此外，在处理 boolean、byte、short 和 char 类型的数组时，也会转换为使用对应的 int 类型的字节码指令来处理。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66gyke338j30qz0aqjvj.jpg" alt="image-20201227144941651.png">

</p>
<p><strong>疑问：既然boolean、byte、short 和 char 类型最终都会转成int处理，那么是不是有些类型实际不需要存在，比如short？</strong></p>
<p><strong><strong>4、运算时的溢出</strong></strong></p>
<p><strong>数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能是一个负数。其实 Java 虚拟机规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为0时会导致虚拟机抛出异常 ArithmeticException。</strong></p>
<p><strong><strong>5、运算模式</strong></strong></p>
<ul>
<li><strong>向最接近数舍入模式（四舍五入）：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的.</strong></li>
<li><strong>向零舍入模式（取整）：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果。</strong></li>
</ul>
<p><strong><strong>6、NaN 值使用</strong></strong></p>
<p><strong>当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN 值来表示。而且所有使用 NaN 值作为操作数的算术操作，结果都会返回 NaN。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#ff79c6">import</span> org.junit.Test<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_08_ArithmeticTest</span> <span style="color:#ff79c6">{</span>
        @Test
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method1</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
<span style="color:#6272a4">//        int n = 10;
</span><span style="color:#6272a4"></span><span style="color:#6272a4">//        int m = n / 0;
</span><span style="color:#6272a4"></span><span style="color:#6272a4">//        System.out.println(m);//java.lang.ArithmeticException: / by zero
</span><span style="color:#6272a4"></span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        <span style="color:#6272a4">// 0.0是一个很小的数值，实际不是0，一个数除以很小的数就是无穷大
</span><span style="color:#6272a4"></span>        <span style="color:#8be9fd">double</span> j <span style="color:#ff79c6">=</span> i <span style="color:#ff79c6">/</span> 0<span style="color:#ff79c6">.</span><span style="color:#50fa7b">0</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>j<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span><span style="color:#6272a4">// Infinity = 无穷大（有符号的使用无穷大表示）
</span><span style="color:#6272a4"></span>

        <span style="color:#8be9fd">double</span> d1 <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">.</span><span style="color:#50fa7b">0</span><span style="color:#ff79c6">;</span>
        <span style="color:#6272a4">/**
</span><span style="color:#6272a4">         * 两个一样的数相除应该是1；
</span><span style="color:#6272a4">         * 但是单纯看分子，0除以任何数都是0；
</span><span style="color:#6272a4">         * 但是单纯看分母，一个数除以0.0（很小的值）应该是无穷大的，所以这个结果不确定。
</span><span style="color:#6272a4">         */</span>
        <span style="color:#8be9fd">double</span> d2 <span style="color:#ff79c6">=</span> d1 <span style="color:#ff79c6">/</span> 0<span style="color:#ff79c6">.</span><span style="color:#50fa7b">0</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>d2<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span><span style="color:#6272a4">//NaN = not a number
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>

</code></pre></div><h3 id="所有算术指令">所有算术指令</h3>
<p><strong>所有算术指令包括：</strong></p>
<ul>
<li>
<p><strong>加法指令：iadd、ladd、fadd、dadd</strong></p>
</li>
<li>
<p><strong>减法指令：isub、lsub、fsub、dsub</strong></p>
</li>
<li>
<p><strong>乘法指令：imul、lmul、fmul、dmul</strong></p>
</li>
<li>
<p><strong>除法指令：idiv、ldiv、fdiv、ddiv</strong></p>
</li>
<li>
<p><strong>求余指令：irem、lrem、frem、drem    // rem = remainder：余数</strong></p>
</li>
<li>
<p><strong>取反指令：ineg、lneg、fneg、dneg    // neg = negation：取反</strong></p>
</li>
<li>
<p><strong>自增指令：iinc</strong></p>
</li>
<li>
<p><strong>位运算指令，又可分为：</strong></p>
</li>
<li>
<ul>
<li><strong>位移指令：ishl（左移）、ishr（右移）、iushr（无符号右移）、lshl（long的左移）、lshr（long的右移）、lushr（long的无符号右移）</strong></li>
<li><strong>按位或指令：ior、lor</strong></li>
<li><strong>按位与指令：iand、land</strong></li>
<li><strong>按位异或指令：ixor、lxor</strong></li>
</ul>
</li>
<li>
<p><strong>比较指令：dcmpg、dcmlp、fcmpg、fcmpl、lcmp</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>


<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_08_ArithmeticTest2</span> <span style="color:#ff79c6">{</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method2</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">float</span> i <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">float</span> j <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>i<span style="color:#ff79c6">;</span>
        i <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">-</span>j<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method3</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> j<span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 100<span style="color:#ff79c6">;</span>
        i <span style="color:#ff79c6">=</span> i <span style="color:#ff79c6">+</span> 10<span style="color:#ff79c6">;</span>
<span style="color:#6272a4">//        i += 10;
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">}</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">method4</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> 80<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> b <span style="color:#ff79c6">=</span> 7<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> c <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">(</span>a <span style="color:#ff79c6">+</span> b<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">*</span> c<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>

    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">int</span> <span style="color:#50fa7b">method5</span><span style="color:#ff79c6">(</span><span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">,</span><span style="color:#8be9fd">int</span> j<span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#ff79c6">return</span> <span style="color:#ff79c6">(</span><span style="color:#ff79c6">(</span>i <span style="color:#ff79c6">+</span> j <span style="color:#ff79c6">-</span> 1<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">&amp;</span> <span style="color:#ff79c6">~</span><span style="color:#ff79c6">(</span>j <span style="color:#ff79c6">-</span> 1<span style="color:#ff79c6">)</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66h1t54g1j30z40erwlo.jpg" alt="image-20201227154559872.png">

</p>
</li>
<li>
<p><strong>i++;（前++） 和 ++i;（后++）——  i的值没有赋值给局部变量的情况</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>


<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_08_ArithmeticTest3</span> <span style="color:#ff79c6">{</span>

    <span style="color:#6272a4">//关于(前)++和(后)++
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method6</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span><span style="color:#ff79c6">;</span>
<span style="color:#6272a4">//        ++i;
</span><span style="color:#6272a4"></span>
<span style="color:#6272a4">//        for(int j = 0;j &lt; 10;j++){}
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">}</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method7</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> a <span style="color:#ff79c6">=</span> i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span><span style="color:#ff79c6">;</span>

        <span style="color:#8be9fd">int</span> j <span style="color:#ff79c6">=</span> 20<span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span> b <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span>j<span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
    <span style="color:#6272a4">//思考
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method8</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 10<span style="color:#ff79c6">;</span>
        i <span style="color:#ff79c6">=</span> i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>i<span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span><span style="color:#6272a4">//10
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div></li>
<li>
<p><strong>i++;</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hcmbqfuj30ui0b345d.jpg" alt="image-20201227220000865.png">

</p>
</li>
<li>
<p><strong>++i;</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hdzy3v8j30tz0d7wn3.jpg" alt="image-20201227220218965.png">

</p>
</li>
<li>
<p><strong>所以for循环中，<code>for(int i=0; i&lt;10; i++){}</code> 和 <code>for(int i=0; i&lt;10; ++i){}</code>是一样的。</strong></p>
</li>
<li>
<p><strong>i++; 和 ++i;   ——  i的值有赋值给变量的情况（i++先load出来栈 ，然后i自增，再把栈里的数出栈压入局部变量(在操作数栈有个临时变量的概念)；而++i是先i自增，然后load出来赋值给局部变量）</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hfuwjs5j312m0juwtb.jpg" alt="image-20201227223650251.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hgswdsnj313c0fkqef.jpg" alt="image-20201228081236710.png">

</p>
</li>
</ul>
<h3 id="比较指令的说明">比较指令的说明</h3>
<ul>
<li><strong>比较指令的作用是比较栈顶两个元素的大小，并将比较结果入栈。</strong></li>
<li><em><strong>比较指令有：dcmpg、dcmpl、fcmpg、fcmpl、lcmp</strong> 。（开头带d的是double，带f的是float，带l的是long。double、float有两个是因为有NaN，long只有一个是因为没有NaN）</em>*
<ul>
<li><strong>与前面讲解的指令类似，首字符 d 表示 double 类型，f 表示 float，l 表示 long</strong></li>
</ul>
</li>
<li><strong>对于 double 和 float 类型的数字，由于 NaN 的存在，各有两个版本的比较指令，以 float 为例，有 fcmpg 和 fcmpl 两个指令，它们的区别在于在数字比较时，若遇到 NaN 值，处理结果不同。</strong></li>
<li><strong>指令 dcmpl 和 dcmpg 也是类似的，根据其命名可以推测其含义，在此不再赘述。</strong></li>
<li><strong>指令 lcmp 针对 long 型整数，由于 long 型整数没有 NaN 值，故无需准备两套指令。</strong></li>
<li><strong>举例：</strong>
<ul>
<li>
<p><strong>指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较，设栈顶的元素为 v2， 栈顶顺位第2位元素为 v1，弹出v1、v2进行比较，若 v1 = v2，则压入0；若 v1 &gt; v2 则压入1；若 v1 &lt; v2 则压入-1。</strong></p>
</li>
<li>
<p><strong>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入1，而 fcmpl 会压入-1。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hixzs8rj305f09wq3a.jpg" alt="image-20201228081954920.png">

</p>
</li>
</ul>
</li>
<li><strong>数值类型的数据才可以谈大小！boolean、引用数据类型不能比较大小。尽管引用类型可以排序，排序的本质就是比较，实际还是比较数值，不能说对象谁大谁小，只能说等于或者不等于（对象地址），如果要排序的就要重写compareTo方法，实际比较的是数值，不是对象本身。（为什么没有比较byte、short、char、int，这部分在“控制转移指令”会解释。这里的比较指令得到一个int值，然后就是条件跳转，对于后面在“控制转移指令”讲解。）</strong></li>
</ul>
<h2 id="类型转换指令">类型转换指令</h2>
<p><strong>类型转换指令说明：</strong></p>
<ol>
<li><strong>类型转换指令可以将两种不同的数值类型进行相互转换。</strong></li>
<li><strong>这些转换操作一般用于实现用户代码中的 <strong>显式类型转换操作</strong> ，或者用来处理</strong>字节码指令集中数据类型相关指令<strong>无法与</strong>数据类型<strong>一一对应的问题。</strong></li>
</ol>
<h3 id="宽化类型转换小转大">宽化类型转换（小转大）</h3>
<p><strong><strong>1、转换规则</strong></strong></p>
<p><strong>Java 虚拟机直接支持以下数值的宽化类型转换(Widening Numeric Conversion，小范围类型向大范围类型的安全转换)。也就是说，并不需要指令执行，包括：</strong></p>
<ul>
<li><strong>从 int 类型到 long、float 或者 double 类型，对应的指令为：i2l、i2f、i2d</strong></li>
<li><strong>从 long 类型到 float、double 类型。对应的指令为：l2f、l2d</strong></li>
<li><strong>从 float类型到 double 类型。对应的指令为：f2d</strong></li>
</ul>
<p><strong><strong>简化为：int &ndash;&gt; long &ndash;&gt; float &ndash;&gt; double</strong></strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hlanxe2j30yx0pr4dp.jpg" alt="image-20210103100603317.png">

</p>
<p><strong><strong>2、精度损失问题</strong></strong></p>
<p><strong>2.1、宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从 int 转换到 long，或者从 int 转换到 double，都不会丢失任何信息，转换前后的值是精确相等的。</strong></p>
<p><strong>2.2、从 int、long 类型数值转换到 float，或者 long 类型数值转换到 double 时，将可能发生丢失精度——可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据 IEEE754 最接近舍入模式所得到的正确整数数值。（float占4字节，float一部分是底数和一部分是指数，精度会降低，所以4字节的int转float精度会丢失，转double会比float的进度高；long和double都是8字节，但是double同样是一部分底数、一部分指数构成。）尽管宽化类型转换实际上是可能发生精度丢失的，但是这种转换永远不会导致 Java 虚拟机抛出运行时异常。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hlv0clnj30og0k7ahd.jpg" alt="image-20210103102751163.png">

</p>
<p><strong><strong>3、补充说明：</strong></strong></p>
<p><strong><strong>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的</strong> ，对于 byte 类型转换为 int，虚拟机并没有做实质性的转化处理，只是简单地通过操作数栈交换了两个数据。而将 byte 转为 long 时，使用的是 i2l，可以看到在内部 byte 在这里已经等同于 int 类型处理，类似的还有 short 类型，这种处理方式有两个特点：</strong></p>
<p><strong>一方面可以减少实际的数据类型，如果为 short 和 byte 都准备一套指令，那么指令的数量就会大增，而 <strong>虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short 和 byte 当作 int 处理也是情理之中</strong> 。</strong></p>
<p><strong>另一方面，由于 <strong>局部变量表中的槽位固定为32位</strong> ，无论是 byte 或者 short 存入局部变量表，都会占用32位空间。从这个角度来说，也没有必要特意区分这几种数据类型。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66hmkkoawj30yw0k4dqw.jpg" alt="image-20210103103204697.png">

</p>
<h3 id="窄化类型转换大转小">窄化类型转换（大转小）</h3>
<p><strong><strong>1、转换规则</strong></strong></p>
<p><strong>Java 虚拟机也直接支持以下 <strong>窄化类型转换</strong> ：</strong></p>
<ul>
<li>
<p><strong>从 int 类型至 byte、short 或者 char 类型。<strong>对应的指令有：i2b、i2s、i2c</strong></strong></p>
</li>
<li>
<p><strong>从 long 类型到 int 类型。<strong>对应的指令有：l2i</strong></strong></p>
</li>
<li>
<p><strong>从 float 类型到 int 或者 long 类型。<strong>对应的指令有：f2i、f2l</strong></strong></p>
</li>
<li>
<p><strong>从 double 类型到 int、long 或者 float 类型。<strong>对应的指令有：d2i、d2l、d2f</strong></strong>

  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66i5f0yasj30vh0nlnaa.jpg" alt="image-20210103104309094 (1).png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66i5qhy3uj30v80iutif.jpg" alt="image-20210103105345515 (1).png">

</p>
</li>
</ul>
<p><strong><strong>2、精度损失问题</strong></strong></p>
<p><strong>窄化类型转换可能会导致转换结果具备不同的正负号（大转小会砍掉一部分，砍掉后可能会导致最高位是1，就会得到负数的值，哪怕原来是正数）、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</strong></p>
<p><strong>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是 Java 虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66i6worbxj30v107ytce.jpg" alt="image-20210103105722435.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66i7366ugj31240fmakc.jpg" alt="image-20210103110553139.png">

</p>
<p><strong><strong>3、补充说明</strong></strong></p>
<p><strong>3.1、当将一个浮点值窄化转换为整数类型 T(T 限于 int 或 long 类型之一)的时候，将遵循以下转换规则：</strong></p>
<ul>
<li><strong>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的0。</strong></li>
<li><strong>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T(int 或 long)的表示范围之内，那转换结果就是 v。否则，将根据 v 的符号，转换为 T 所能表示的最大或者最小正数。</strong></li>
</ul>
<p><strong>3.2、当将一个 double 类型窄化转换为 float 类型时，将遵循以下转换规则：</strong></p>
<p><strong>通过向最接近数舍入模式舍入一个可以使用 float 类型表示的数字。最后结果根据下面这3条规则判断：</strong></p>
<ul>
<li>
<p><strong>如果转换结果的绝对值太小而无法使用 float 来表示，将返回 float 类型的正负零。</strong></p>
</li>
<li>
<p><strong>如果转换结果的绝对值太大而无法使用 float 来表示，将返回 float 类型的正负无穷大。</strong></p>
</li>
<li>
<p><strong>对于 double 类型的 NaN 值将按规定转换为 float 类型的 NaN 值。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66i82tzicj30kd0ot7et.jpg" alt="image-20210103113353836.png">

</p>
</li>
</ul>
<h2 id="对象的创建与访问指令">对象的创建与访问指令</h2>
<p><strong>Java 是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作（包括从类创建的对象，还有数组对象），可进一步细分为创建指令、字段访问指令、数组操作指令和类型检查指令。</strong></p>
<h3 id="创建指令">创建指令</h3>
<p><strong>虽然类实例和数组都是对象，但 Java 虚拟机对类实例和数组的创建与操作使用了不同的字节码指令：</strong></p>
<p><strong><strong>1、创建类实例的指令：</strong></strong></p>
<ul>
<li><strong><strong>创建类实例的指令：new</strong></strong>
<ul>
<li>
<p><strong>它接收一个操作数，为指向常量池的索引，表示要创建的类型，执行完成后，将对象的引用压入栈</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#ff79c6">import</span> java.io.File<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_10_NewTest1</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">//1.创建指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">newInstance</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        Object obj <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Object<span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>

        File file <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> File<span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;words.txt&#34;</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>

</code></pre></div></li>
</ul>
</li>
</ul>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ib9c7t4j314h0jdgw7.jpg" alt="image-20210103160229339.png">

</p>
<ul>
<li>
<p><strong>以前对于一个对象引用存放的简化解释是虚拟机栈</strong></p>
</li>
<li>
<p><strong>而现在是具体的解释，实际是局部变量表存放着对象的地址（不是临时的操作数栈存放的地址）</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66iccfxtaj31ay0mkani.jpg" alt="image-20210103163208405.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ickqr24j319y0mn49x.jpg" alt="image-20210103164304973.png">

</p>
</li>
</ul>
<p><strong><strong>2、创建数组的指令：</strong></strong></p>
<p><strong><strong>创建数组的指令：newarray、anewarray、multianewarray</strong></strong></p>
<ul>
<li><strong>newarray：创建基本类型数组</strong></li>
<li><strong>anewarray：创建引用类型数组</strong></li>
<li><strong>multianewarray：创建多维数组</strong></li>
</ul>
<p><strong>上述创建指令可以用于创建对象或者数组，由于对象和数组在 Java 中的广泛使用，这些指令的使用频率也非常高</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#ff79c6">import</span> java.io.File<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_10_NewTest2</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">//1.创建指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">newArray</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> intArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>
        Object<span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> objArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> Object<span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>
        <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> mintArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>

        String<span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> strArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> String<span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ie5fot7j311c0o04dp.jpg" alt="image-20210103170754372.png">

</p>
<h3 id="字段访问指令">字段访问指令</h3>
<p><strong>对象创建后，就可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素。</strong></p>
<ul>
<li><strong><strong>访问类字段(static 字段，或者称为类变量)的指令：getstatic（压字段入操作数栈）、putstatic（出操作数 栈赋值给字段）</strong></strong></li>
<li><strong><strong>访问类实例字段(非 static 字段，或者称为实例变量)的指令：getfield、putfield</strong></strong></li>
</ul>
<p><strong>举例：</strong></p>
<p><strong>以 getstatic 指令为例，它含有一个操作数，为指向常量池的 Fieldref 索引，它的作用就是获取 Fieldref 指定的对象或者值，并将其压入操作数栈。</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">sayHello</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>
    System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span><span style="color:#f1fa8c">&#34;Hello&#34;</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p><strong>对应的字节码指令：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">0 getstatic #8 <span style="color:#ff79c6">&lt;</span>java<span style="color:#ff79c6">/</span>lang<span style="color:#ff79c6">/</span>System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">&gt;</span>   <span style="color:#6272a4">// out就是静态字段
</span><span style="color:#6272a4"></span>3 ldc #9 <span style="color:#ff79c6">&lt;</span>Hello<span style="color:#ff79c6">&gt;</span>
5 invokevirtual #10 <span style="color:#ff79c6">&lt;</span>java<span style="color:#ff79c6">/</span>io<span style="color:#ff79c6">/</span>PrintStream<span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">&gt;</span>
8 <span style="color:#ff79c6">return</span>
</code></pre></div><h3 id="数组操作指令">数组操作指令</h3>
<p><strong>数组操作指令主要有：xastore 和 xaload 指令。具体为：</strong></p>
<ul>
<li><strong>把一个数组元素加载到操作数栈的指令：baload（byte、boolean都是b，a是数组）、caload、saload、iaload、laload、faload、daload、aaload</strong></li>
<li><strong>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、lastore、fastore、dastore、aastore</strong></li>
<li><strong>取数组长度的指令：arraylength</strong>
<ul>
<li><strong>该指令弹出栈顶的数组元素，获取数组的长度，将长度压入栈</strong></li>
</ul>
</li>
<li><strong>之前的store是出栈后把数据存放到局部变量表中，这里操作数组的store不一样，局部变量表只是数组的地址，所以这里的store会把数据存放到对空间中真正的位置。</strong></li>
</ul>
<p><strong><strong>说明：</strong></strong></p>
<ul>
<li><strong>指令 xaload 表示将数组的元素压栈，比如 saload、caload 分别表示压入 short 数组和 char 数组。指令 xaload 在执行时，要求操作数中栈顶元素为 <strong>数组索引 i</strong> ，栈顶顺位第2个元素为 <strong>数组引用 a</strong> ，该指令会弹出栈顶这两个元素，并将 a[i] 重新压入堆栈。</strong></li>
<li><strong>xastore 则专门针对数组操作，以 iastore 为例，它用于给一个 int 数组的给定索引赋值。在 iastore 执行前，操作数栈顶需要以此准备3个元素： <strong>值、索引、数组引用</strong> ，iastore 会弹出这3个值，并将值赋给数组中指定索引的位置.</strong></li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_10_NewTest4</span> <span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">//3.数组操作指令
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">setArray</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> intArray <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd">int</span><span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>
        intArray<span style="color:#ff79c6">[</span>3<span style="color:#ff79c6">]</span> <span style="color:#ff79c6">=</span> 20<span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>intArray<span style="color:#ff79c6">[</span>1<span style="color:#ff79c6">]</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
  
<span style="color:#6272a4">//        boolean[] arr = new boolean[10];
</span><span style="color:#6272a4"></span><span style="color:#6272a4">//        arr[1] = true;
</span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">}</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">arrLength</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>

        <span style="color:#8be9fd">double</span><span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> arr <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> <span style="color:#8be9fd">double</span><span style="color:#ff79c6">[</span>10<span style="color:#ff79c6">]</span><span style="color:#ff79c6">;</span>
        System<span style="color:#ff79c6">.</span><span style="color:#50fa7b">out</span><span style="color:#ff79c6">.</span><span style="color:#50fa7b">println</span><span style="color:#ff79c6">(</span>arr<span style="color:#ff79c6">.</span><span style="color:#50fa7b">length</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>
</code></pre></div><p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ilw1u7yj31640jeakf.jpg" alt="image-20210110173405240 (1).png">

</p>
<ul>
<li>
<p><strong>int数组的存储和寻找：iastore、iaload</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66imcpj8gj31hs0m5nfp.jpg" alt="image-20210110173106848.png">

</p>
</li>
<li>
<p><strong>boolean数组</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66in3t78vj315n0oidt7.jpg" alt="image-20210110173750112.png">

</p>
</li>
<li>
<p><strong>数组长度</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ingtkfoj315i0fjak3.jpg" alt="image-20210110174111458.png">

</p>
</li>
</ul>
<h3 id="类型检查指令">类型检查指令</h3>
<p><strong>检查类实例或数组类型的指令：instanceof、checkcast</strong></p>
<ul>
<li>
<p><strong>指令 checkcast 用于检查类型强制转换是否可以进行。如果可以进行，那么 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常。</strong></p>
</li>
<li>
<p><strong>指令 instanceof 用来判断给定对象是否是某一个类的实例，它会将判断结果压入操作数栈。（instanceof 是判断是不是一个类的实例，如果是就可以用checkcast 强转）</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ioerf6qj30zj0ktak2.jpg" alt="image-20210110174837670.png">

</p>
</li>
</ul>
<h2 id="方法调用与返回指令">方法调用与返回指令</h2>
<h3 id="方法调用指令">方法调用指令</h3>
<p><strong><strong>方法调用指令：invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamic</strong></strong></p>
<p><strong>以下5条指令用于方法调用：</strong></p>
<ul>
<li>
<p><strong>invokevirtual 指令用于调用对象的实例方法，根据对象的实际类型进行分派(虚方法分派)，支持多态。这也是 Java 语言中 <strong>最常见的方法分派方式</strong> 。（动态绑定，有方法的重写）</strong></p>
</li>
<li>
<p><strong>invokeinterface 指令用于 <strong>调用接口方法</strong> ，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用。（这是编译的时候调用接口方法，运行的时候会调用实现类的方法）</strong></p>
</li>
<li>
<p><strong>invokespecial 指令用于调用一些需要特殊处理的实例方法，包括 <strong>实例初始化方法(构造器)、私有方法和父类方法</strong> （这些不存在方法重写。父类方法是往上一层找，没有就继续往上找，这也是确定的方法，即静态绑定。）。这些方法都是</strong>静态类型绑定<strong>的，不会在调用时进行动态派发。</strong></p>
</li>
<li>
<p><strong>invokestatic 指令用于调用命名 <strong>类中的类方法(static 方法)</strong> 。这是</strong>静态绑定<strong>的。</strong></p>
</li>
<li>
<p><strong>invokedynamic 调用动态绑定的方法，这个是 JDK 1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面4条调用指令的分派逻辑都固化在 Java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的。（这个暂时不讨论）</strong></p>
</li>
<li>
<p><strong>invokespecial：静态分派</strong>

  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ir2mggij313j0jw7jo.jpg" alt="image-20210110200110019.png">

</p>
</li>
<li>
<p><strong>如果改成public方法，就变成invokevirtual</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66irlina5j31450kdaoc.jpg" alt="image-20210110200224079.png">

</p>
</li>
<li>
<p><strong>invokestatic: 静态分派</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66is9kbuhj31220ax461.jpg" alt="image-20210110200451125.png">

</p>
</li>
<li>
<p><strong>改成私有的，不变</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66isp5orwj31260ag7cj.jpg" alt="image-20210110200538570.png">

</p>
</li>
<li>
<p><strong>invokeinterface</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ithjvz3j314f0huwqp.jpg" alt="image-20210110201225144.png">

</p>
</li>
<li></li>
<li></li>
<li>
<p><strong>invokevirtual: 动态分派</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66iunav7pj310g0d0n3o.jpg" alt="image-20210110201527874.png">

</p>
<p><strong>补充例子：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#ff79c6">package</span> _10<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">_12_InterfaceMethodTest</span> <span style="color:#ff79c6">{</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">main</span><span style="color:#ff79c6">(</span>String<span style="color:#ff79c6">[</span><span style="color:#ff79c6">]</span> args<span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
        AA aa <span style="color:#ff79c6">=</span> <span style="color:#ff79c6">new</span> BB<span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>

        aa<span style="color:#ff79c6">.</span><span style="color:#50fa7b">method2</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>

        AA<span style="color:#ff79c6">.</span><span style="color:#50fa7b">method1</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">;</span>
    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>


<span style="color:#8be9fd;font-style:italic">interface</span> <span style="color:#50fa7b">AA</span><span style="color:#ff79c6">{</span>
    <span style="color:#6272a4">// JDK8中接口可以定义静态方法
</span><span style="color:#6272a4"></span>    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">static</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method1</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>

    <span style="color:#ff79c6">}</span>

    <span style="color:#6272a4">/**
</span><span style="color:#6272a4">     * JDK8新特性，default修饰的方法不是抽象方法，
</span><span style="color:#6272a4">     * 所以实现接口时实现类不需要实现接口中的default修饰的方法。
</span><span style="color:#6272a4">     * 当然也可以去实现default方法。
</span><span style="color:#6272a4">     */</span>
    <span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#ff79c6">default</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">method2</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span><span style="color:#ff79c6">{</span>

    <span style="color:#ff79c6">}</span>
<span style="color:#ff79c6">}</span>

<span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">BB</span> <span style="color:#8be9fd;font-style:italic">implements</span> AA<span style="color:#ff79c6">{</span>

<span style="color:#ff79c6">}</span>
</code></pre></div><p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66ixw2xpjj313z0sfdst.jpg" alt="image-20210110202323416.png">

</p>
</li>
</ul>
<h3 id="方法返回指令">方法返回指令</h3>
<p><strong>方法调用结束前，需要进行返回。方法返回指令是</strong>根据返回值的类型区分<strong>的</strong></p>
<ul>
<li>
<p><strong>包括 ireturn(当返回值是 boolean、byte、char、short 和 int 类型时使用)、lreturn、freturn、dreturn 和 areturn。</strong></p>
</li>
<li>
<p><strong>另外还有一条 return 指令供声明为 void 的方法、实例初始化方法以及类和接口的类初始化方法使用</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66izxi077j30ga0960to.jpg" alt="image-20210110202504157.png">

</p>
</li>
</ul>
<p><strong>举例：</strong></p>
<p><strong>通过 ireturn 指令，将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中(因为调用者非常关心函数的返回值)，所有在当前函数操作数栈中的其他元素都会被丢弃。</strong></p>
<p><strong>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区。</strong></p>
<p><strong>最后，会丢弃当前方法的整个帧，恢复调用者的帧，并将控制权转交给调用者</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66j1dlh4pj30dy0c0dhj.jpg" alt="image-20210110222252508.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66j1m8kl9j312f0yynmg.jpg" alt="image-20210110222852470.png">

</p>
<h2 id="操作数栈管理指令">操作数栈管理指令</h2>
<p><strong>如同操作一个普通数据结构中的堆栈那样，JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令。</strong></p>
<p><strong>这类指令包括如下内容：</strong></p>
<ul>
<li><strong>将一个或两个元素从栈顶弹出，并且直接废弃：pop、pop2。</strong></li>
<li><strong>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。</strong></li>
<li><strong>将栈最顶端的两个 Slot 数值位置交换：swap。Java 虚拟机没有提供交换两个64位数据类型(long、double)数值的指令。（没有swap2）</strong></li>
<li><strong>指令 nop 是一个非常特殊的指令，它的字节码为0x00。和汇编语言中的 nop 一样，它表示什么都不做，这条指令一般可用于调试、占位等。</strong></li>
</ul>
<p><strong>这些指令属于通用型，对栈的压入或者弹出无需指明数据类型。（比如前面说的goto）</strong></p>
<p><strong>说明：</strong></p>
<ul>
<li>
<p><strong>不带 _x 的指令是复制栈顶数据并压入栈顶。包括两个指令，dup 和 dup2，dup 的系数代表要复制的 Slot 个数。</strong></p>
<ul>
<li><strong>dup 开头的指令用于复制1个 Slot 的数据。例如1个 int 或1个 reference 类型数据。</strong></li>
<li><strong>dup2 开头的指令用于复制2个 Slot 的数据。例如1个 long，或2个 int，或1个 int 加1个 float 类型数据。</strong></li>
</ul>
</li>
<li>
<p><strong>带 _x 的指令是复制栈顶数据并插入栈顶以下的某个位置。共有4个指令，dup_x1、dup2_x1、dup_x2、dup2_x2。对于带 _x 的复制插入指令，只要将指令的 dup 和 x 的系数相加，结果即为需要插入的位置。因此</strong></p>
<ul>
<li>
<p>dup_x1 插入位置：1+1=2，即栈顶2个 Slot 下面</p>
</li>
<li>
<p>dup_x2 插入位置：1+2=3，即栈顶3个 Slot 下面</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66j9y7mrjj30gr0cstap.jpg" alt="image-20210110224559373.png">

</p>
</li>
</ul>
</li>
<li>
<p><strong>dup2_x1 插入位置：2+1=3，即栈顶3个 Slot 下面</strong></p>
</li>
<li>
<p><strong>dup2_x2 插入位置：2+2=4，即栈顶4个 Slot 下面</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66jalgeufj30js0gjtcf.jpg" alt="image-20210111074908849.png">

</p>
</li>
<li>
<p><strong>pop：将栈顶的1个 Slot 数值出栈。例如1个 short 类型数值</strong></p>
</li>
<li>
<p><strong>pop2：将栈顶的2个 Slot 数值出栈。例如1个 double 类型数值，或者2个 int 类型数值</strong></p>
</li>
</ul>
<h2 id="控制转移指令">控制转移指令</h2>
<p><strong>程序流程离不开条件控制，为了支持条件跳转，虚拟机提供了大量字节码指令，大体上可以分为：</strong></p>
<p><strong>1）比较指令、2）条件跳转指令、3）比较条件跳转指令、4）多条件分支跳转指令、5）无条件跳转指令等。</strong></p>
<p><strong>比较指令（在前面：本章 - 算术指令 - 比较指令的说明）</strong></p>
<h3 id="条件跳转指令">条件跳转指令</h3>
<p><strong>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用</strong>比较指令<strong>进行栈顶元素的准备，然后进行条件跳转。</strong></p>
<p><strong>条件跳转指令有： <strong>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull</strong> 。这些指令都接收两个字节的操作数，用于计算跳转的位置(16位符号整数作为当前位置的 offset)。</strong></p>
<p><strong>它们的统一含义为： <strong>弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置</strong> 。</strong></p>
<p><strong>具体说明：</strong> （比较指令 的结果使用如下指令进行跳转处理）</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h66jh1rtshj30p009iq5o.jpg" alt="image-20210111214046941.png">

</p>
<p><strong><strong>注意：</strong></strong></p>
<p><strong>1、与前面运算规则一致：</strong></p>
<ul>
<li><strong>对于 boolean、byte、char、short 类型的条件分支比较操作，都是使用 int 类型的比较指令完成。</strong></li>
<li><strong>对于 long、float、double 类型的条件分支比较操作，则会先执行相应类型的 <strong>比较运算指令</strong> ，运算指令会返回一个整型值到操作数栈中，随后再执行 int 类型的条件分支比较操作来完成整个分支跳转。</strong></li>
</ul>
<p><strong>2、由于各类型的比较最终都会转为 int 类型的比较操作，所以 Java 虚拟机提供的 int 类型的条件分支指令是最为丰富和强大的</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67hkoo2t1j30t10g17d9.jpg" alt="image-20210112075938842.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67hlsyngtj30uh0a0afg.jpg" alt="image-20210112080312509.png">

</p>
<p><strong>详细分析一下两个float的比较</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67hmgg5ycj311s0epk05.jpg" alt="image-20210112080853101.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67hmmilx1j319o0rjdw3.jpg" alt="image-20210112082408799.png">

</p>
<h3 id="比较条件跳转指令">比较条件跳转指令</h3>
<p><strong>比较条件跳转指令类似于比较指令和条件跳转指令的结合体，它将比较和跳转两个步骤合二为一。</strong></p>
<p><strong>这类指令有：if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和 if_acmpne。</strong></p>
<p>**其中指令助记符加上 &ldquo;if_&rdquo; 后，以字符 &ldquo;i&rdquo; 开头的指令针对 **int 型**整数操作(也包括 short 和 byte 类型)，以字符 &ldquo;a&rdquo; 开头的指令表示**对象引用**的比较。**</p>
<p><strong><strong>具体说明：</strong></strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kintr4fj30pm09e436.jpg" alt="image-20210111215135234.png">

</p>
<p><strong>这些指令都接收两个字节的操作数作为参数，用于计算跳转的位置。同时在执行指令时，栈顶需要准备两个元素进行比较。指令执行完成后，栈顶的这两个元素被清空，且 <strong>没有任何数据入栈</strong> 。 <strong>如果预设条件成立，则执行跳转，否则，继续执行下一条语句</strong> 。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kjlt0ktj31340kh14h.jpg" alt="image-20210113080538876.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kjyedlpj312s0icdtb.jpg" alt="image-20210113080948625.png">

</p>
<p><strong>引用比较</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kkhfegtj31350mntku.jpg" alt="image-20210113081720585.png">

</p>
<h3 id="多条件分支跳转">多条件分支跳转</h3>
<p><strong>多条件分支跳转指令是专为 switch-case 语句设计的，主要有 tableswitch 和 lookupswitch。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67klpa45nj30t103ugmo.jpg" alt="image-20210115075757278.png">

</p>
<p><strong>从助记符上看，两者都是 switch 语句的实现，它们的区别：</strong></p>
<ul>
<li><strong>tableswitch 要求 <strong>多个条件分支值是连续的</strong> ，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置， <strong>因此效率比较高</strong> 。</strong></li>
<li><strong>lookupswitch 内部 <strong>存放着各个离散的 case-offset 对</strong> ，每次执行都要搜索全部的 case-offset 对，找到匹配的 case 值，并根据对应的 offset 计算跳转地址， <strong>因此效率较低</strong> 。</strong></li>
</ul>
<p><strong>指令 tableswitch 的示意图如下图所示。由于 tableswitch 的 case 值是连续的，因此只需要记录最低值和最高值，以及每一项对应的 offset 偏移量，根据给定的 index 值通过简单的计算即可直接定位到 offset。</strong></p>
<p><strong>指令 lookupswitch 处理的是离散的 case 值，但是出于效率考虑， <strong>将 case-offset 对按照 case 值大小排序</strong> ，给定 index 时，需要查找与 index 相等的 case，获得其 offset，如果找不到则跳转到 default。</strong></p>
<p><strong>tableswitch</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kmyys5qj310j0mmdt7.jpg" alt="image-20210115081208832.png">

</p>
<p><strong>case穿透</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67knd6afuj311z0oa4e0.jpg" alt="image-20210115081356275.png">

</p>
<p><strong>lookupswitch</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kntkoztj30xr0j3aid.jpg" alt="image-20210115081631882.png">

</p>
<p>jdk7新特性：引入String类型</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kp2iflbj31240kvwpb.jpg" alt="image-20210115081841876.png">

</p>
<h3 id="无条件跳转">无条件跳转</h3>
<p>**目前主要的无条件跳转指令为 goto。指令 goto 接收两个字节的操作数，共同组成一个带符号的整数， <strong>用于指定指令的偏移量，指令执行的目的就是跳转到偏移量给定的位置处</strong> **</p>
<p><strong>如果指令偏移量太大，超过双字节的带符号整数的范围，则可以使用指令 goto_w，它和 goto 有相同的作用，但是它接收4个字节的操作数，可以表示更大的地址范围。</strong></p>
<p><strong>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，但主要用于 try-finally 语句，且已经被虚拟机逐渐废弃，故不在这里介绍</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kppgjz0j30t7073di2.jpg" alt="image-20210115082208568.png">

</p>
<p><strong>while和for循环的区别</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kqc5gcpj30uz0guk1s.jpg" alt="image-20210116101233602.png">

</p>
<h2 id="异常处理指令">异常处理指令</h2>
<h3 id="抛出异常指令">抛出异常指令</h3>
<p><strong>（1）athrow 指令</strong></p>
<p><strong>在 Java 程序中显式抛出异常的操作(throw 语句)都是由 athrow 指令来实现。</strong></p>
<p><strong>除了使用 throw 语句显式抛出异常情况之外， <strong>JVM 规范还规定了许多运行时异常会在其它 Java 虚拟机指令检测到异常状况时自动抛出</strong> 。例如，在之前介绍的整数运算时，当除数为零时，虚拟机会在 idiv 或 ldiv 指令中抛出 ArithmeticException 异常。</strong></p>
<p><strong>（2）注意</strong></p>
<p><strong>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是 <strong>在抛异常时，Java 虚拟机会清除操作数栈上的所有内容，而后将异常实例压入调用者操作数栈上</strong> 。（效果类似于return）</strong></p>
<p><strong><strong>异常及异常的处理：</strong></strong></p>
<p><strong>过程一：异常对象的生成过程 &mdash;&gt; throw(手动/自动)  &mdash;&gt;  <strong>指令：athrow</strong> （手动抛出能看到athrow指令，自动抛出字节码看不到，运行时才会有。抛出来的是一个对象，所以是a）</strong></p>
<p><strong>过程二：异常的处理：抓抛模型 try-catch-finally       &mdash;&gt; <strong>使用异常表</strong></strong></p>
<h3 id="异常处理与异常表">异常处理与异常表</h3>
<p><strong>1、处理异常</strong></p>
<p><strong>在 Java 虚拟机中， <strong>处理异常</strong> (catch 语句)不是由字节码指令来实现的(早期使用 jsr、ret 指令)，而是 <strong>采用异常表来完成的</strong> 。</strong></p>
<p><strong>2、异常表</strong></p>
<p><strong>如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：</strong></p>
<ul>
<li><strong>起始位置</strong></li>
<li><strong>结束位置</strong></li>
<li><strong>程序计数器记录的代码处理的偏移地址</strong></li>
<li><strong>被捕获的异常类在常量池中的索引</strong></li>
</ul>
<p><strong><strong>当一个异常被抛出时，JVM 会在当前的方法里寻找一个匹配的处理，如果没有找到，这个方法会强制结束并弹出当前栈帧，</strong> 并且异常会重新抛给上层调用的方法(在调用方法栈帧)。如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程。（所以异常一定要处理，尽量不要直接抛给JVM）</strong></p>
<p><strong>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。</strong> 在这种情况下，  <strong>如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标</strong> 。</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67krxlqc7j316s0bvtfv.jpg" alt="image-20210116112812421.png">

</p>
<p><strong>抛出异常的情况</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67ksgtbyrj31az0lr4dm.jpg" alt="image-20210116113128425.png">

</p>
<p><strong>没有Exceptions属性，异常表没有任何信息</strong></p>
<p><strong>方法抛出异常的情况</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kt7h1yhj31ab0c87ca.jpg" alt="image-20210116113727051.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kti646vj30ny06v0vn.jpg" alt="image-20210116113813539.png">

</p>
<p><strong>Code属性刻画的是方法体，而throws是在方法的声明处，throws是刻画方法的，相当于另外的属性，所以跟Code属性并列的，不会放到Code属性里面（即不会在字节码指令体现）。</strong></p>
<p><strong>运行时系统抛出的异常，字节码指令是看不到athrow的</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kxlea1wj31940cwjyn.jpg" alt="image-20210116114154945.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kxtekspj30oo04z76a.jpg" alt="image-20210116114259001.png">

</p>
<p><strong>try-catch</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kyfkeg9j31ab0j648q.jpg" alt="image-20210116114910254.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67kz6uq57j31dq0ubx14.jpg" alt="image-20210116181449716.png">

</p>
<p><strong>这就很清楚为什么try-catch之后能保证程序不会异常退出或程序崩溃，还能健壮的运行</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l18t6vlj30ih0edq78.jpg" alt="image-20210116183913187.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l1gj87yj31lf0obqmq.jpg" alt="image-20210116191328863.png">

</p>
<p><strong>返回的是str的复制品，最初的str已经被修改了，后面可以有个例子：如果修改的不是str而是对象的值，那么return后的结果是finally中修改过的，而这里只是复制了对象的地址，所以值还是原来hello的值。</strong></p>
<p><em><strong>如果finally修改的是对象的值</strong></em></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l338xg1j31fi0t0dxg.jpg" alt="image-20210116192334081.png">

</p>
<h2 id="同步控制指令">同步控制指令</h2>
<p><strong>Java 虚拟机支持两种同步结构：<strong>方法级同步</strong> 和  <strong>方法内部一段指令序列的同步</strong> ，这两种同步都是使用 monitor （监听器）来支持的。</strong></p>
<h3 id="方法级的同步">方法级的同步</h3>
<p><strong>方法级的同步：是 <strong>隐式的</strong> ，即无需通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法。</strong></p>
<p><strong>当调用方法时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否设置。</strong></p>
<ul>
<li><strong>如果设置了，执行线程将先持有同步锁，然后执行方法， <strong>最后在方法完成(无论是正常完成还是非正常完成)时释放同步锁</strong> 。</strong></li>
<li><strong>在方法执行期间，执行线程持有了同步锁，其它任何线程都无法再获得同一个锁。</strong></li>
<li><strong>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放。</strong></li>
</ul>
<p><strong>ACC_SYNCHRONIZED是方法的访问标识，前面讲过</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l40nqozj30y50lztl8.jpg" alt="image-20210116210348836.png">

</p>
<p><strong>举例：</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd">int</span> i <span style="color:#ff79c6">=</span> 0<span style="color:#ff79c6">;</span>

<span style="color:#8be9fd;font-style:italic">public</span> <span style="color:#8be9fd;font-style:italic">synchronized</span> <span style="color:#8be9fd">void</span> <span style="color:#50fa7b">add</span><span style="color:#ff79c6">(</span><span style="color:#ff79c6">)</span> <span style="color:#ff79c6">{</span>
  i<span style="color:#ff79c6">+</span><span style="color:#ff79c6">+</span><span style="color:#ff79c6">;</span>
<span style="color:#ff79c6">}</span>

对应字节码：（字节码看不到synchronized关键字）
0 aload_0
1 dup
2 getdield #2 <span style="color:#ff79c6">&lt;</span>com<span style="color:#ff79c6">/</span>atguigu<span style="color:#ff79c6">/</span>java1<span style="color:#ff79c6">/</span>SynchronizedTest<span style="color:#ff79c6">.</span><span style="color:#50fa7b">i</span><span style="color:#ff79c6">&gt;</span>
5 iconst_1
6 iadd
7 putfield #2 <span style="color:#ff79c6">&lt;</span>com<span style="color:#ff79c6">/</span>atguigu<span style="color:#ff79c6">/</span>java1<span style="color:#ff79c6">/</span>SynchronizedTest<span style="color:#ff79c6">.</span><span style="color:#50fa7b">i</span><span style="color:#ff79c6">&gt;</span>
10 <span style="color:#ff79c6">return</span>
</code></pre></div><p><strong>说明：</strong></p>
<p><strong>这段代码和普通的无同步操作的代码没有什么不同，没有使用 monitorenter（加锁） 和 monitorexit （释放锁）进行同步区控制。这是因为，对于同步方法而言， <strong>当虚拟机通过方法的访问标识符判断是一个同步方法时，会自动在方法调用前进行加锁</strong> ，当同步方法执行完毕后，不管方法是正常结束还是有异常抛出，均会由虚拟机释放这个锁。因此，对于同步方法而言，monitorenter 和 monitorexit 指令是隐式存在的，并未直接出现在字节码中。</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l5m8ru0j30vc06eaed.jpg" alt="image-20210116222123444.png">

</p>
<h3 id="方法内指定指令序列的同步">方法内指定指令序列的同步</h3>
<p><strong>同步一段指令集序列：通常是由 Java 中的 synchronized 语句块来表示的。JVM 的指令集有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义。</strong></p>
<p><strong>当一个线程进入同步代码块时，它使用 monitorenter 指令请求进入。如果当前对象的监视器计数器为0，则它会被准许进入，若为1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，知道对象的监视器计数器为0，才会被允许进入同步块。</strong></p>
<p><strong>当线程退出同步块时，需要使用 monitorexit 声明退出。在 Java 虚拟机中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态。</strong></p>
<p><strong><strong>指令 monitorenter 和 monitorexit 在执行时，都需要在操作数栈顶压入对象，之后 monitorenter 和 monitorexit 的锁定和释放都是针对这个对象的监视器进行的。</strong></strong></p>
<p><strong>下图展示了监视器如何保护临界区代码不同时被多个线程访问，只有当线程4离开临界区后，线程1、2、3才有可能进入</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l7i04dbj30kq0a4dj3.jpg" alt="image-20210116222409892.png">

</p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67l7o3mxlj30tx093jtw.jpg" alt="image-20210116223554251.png">

</p>
<p><strong>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都必须执行其对应的 monitorexit 指令，而无论这个方法是正常结束还是异常结束。</strong></p>
<p><strong>为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行， <strong>编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常</strong> ，它的目的就是用来执行 monitorexit 指令。</strong></p>
<p><strong>这种方式能看到monitorenter 和 monitorexit</strong></p>
<p>
  <img src="http://tva1.sinaimg.cn/large/006QQPIfly1h67lfqom1pj31040ro490.jpg" alt="image-20210116223347995.png">

</p>


                

                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/post/1057class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" data-toggle="tooltip" data-placement="top" title="17、Class文件结构（JVM）">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/post/1059%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/" data-toggle="tooltip" data-placement="top" title="19、类的加载过程详解（JVM）">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>
                

            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">标签</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/tags/activemq" title="activemq">
                            activemq
                        </a>
                        
                        
                        
                        <a href="/tags/ajax" title="ajax">
                            ajax
                        </a>
                        
                        
                        
                        <a href="/tags/cookie" title="cookie">
                            cookie
                        </a>
                        
                        
                        
                        <a href="/tags/datax" title="datax">
                            datax
                        </a>
                        
                        
                        
                        <a href="/tags/docker" title="docker">
                            docker
                        </a>
                        
                        
                        
                        <a href="/tags/elasticsearch" title="elasticsearch">
                            elasticsearch
                        </a>
                        
                        
                        
                        <a href="/tags/filter" title="filter">
                            filter
                        </a>
                        
                        
                        
                        <a href="/tags/hadoop" title="hadoop">
                            hadoop
                        </a>
                        
                        
                        
                        <a href="/tags/hbase" title="hbase">
                            hbase
                        </a>
                        
                        
                        
                        <a href="/tags/hive" title="hive">
                            hive
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/java" title="java">
                            java
                        </a>
                        
                        
                        
                        <a href="/tags/javascript" title="javascript">
                            javascript
                        </a>
                        
                        
                        
                        <a href="/tags/javaweb" title="javaweb">
                            javaweb
                        </a>
                        
                        
                        
                        <a href="/tags/jdbc" title="jdbc">
                            jdbc
                        </a>
                        
                        
                        
                        <a href="/tags/jquery" title="jquery">
                            jquery
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/jsp" title="jsp">
                            jsp
                        </a>
                        
                        
                        
                        <a href="/tags/juc" title="juc">
                            juc
                        </a>
                        
                        
                        
                        <a href="/tags/jvm" title="jvm">
                            jvm
                        </a>
                        
                        
                        
                        <a href="/tags/jwt" title="jwt">
                            jwt
                        </a>
                        
                        
                        
                        <a href="/tags/kafka" title="kafka">
                            kafka
                        </a>
                        
                        
                        
                        <a href="/tags/linux" title="linux">
                            linux
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/maven" title="maven">
                            maven
                        </a>
                        
                        
                        
                        <a href="/tags/minio" title="minio">
                            minio
                        </a>
                        
                        
                        
                        <a href="/tags/mongodb" title="mongodb">
                            mongodb
                        </a>
                        
                        
                        
                        <a href="/tags/mybatis" title="mybatis">
                            mybatis
                        </a>
                        
                        
                        
                        
                        
                        <a href="/tags/mysql" title="mysql">
                            mysql
                        </a>
                        
                        
                        
                        <a href="/tags/netty" title="netty">
                            netty
                        </a>
                        
                        
                        
                        <a href="/tags/nginx" title="nginx">
                            nginx
                        </a>
                        
                        
                        
                        <a href="/tags/react" title="react">
                            react
                        </a>
                        
                        
                        
                        <a href="/tags/redis" title="redis">
                            redis
                        </a>
                        
                        
                        
                        <a href="/tags/scala" title="scala">
                            scala
                        </a>
                        
                        
                        
                        <a href="/tags/servlet" title="servlet">
                            servlet
                        </a>
                        
                        
                        
                        <a href="/tags/session" title="session">
                            session
                        </a>
                        
                        
                        
                        <a href="/tags/shiro" title="shiro">
                            shiro
                        </a>
                        
                        
                        
                        <a href="/tags/spark" title="spark">
                            spark
                        </a>
                        
                        
                        
                        <a href="/tags/spring" title="spring">
                            spring
                        </a>
                        
                        
                        
                        <a href="/tags/springboot" title="springboot">
                            springboot
                        </a>
                        
                        
                        
                        <a href="/tags/springcloud" title="springcloud">
                            springcloud
                        </a>
                        
                        
                        
                        <a href="/tags/springmvc" title="springmvc">
                            springmvc
                        </a>
                        
                        
                        
                        <a href="/tags/springsecurity" title="springsecurity">
                            springsecurity
                        </a>
                        
                        
                        
                        <a href="/tags/tomcat" title="tomcat">
                            tomcat
                        </a>
                        
                        
                        
                        <a href="/tags/vue" title="vue">
                            vue
                        </a>
                        
                        
                        
                        <a href="/tags/xml" title="xml">
                            xml
                        </a>
                        
                        
                        
                        <a href="/tags/zookeeper" title="zookeeper">
                            zookeeper
                        </a>
                        
                        
                        
                        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95" title="数据结构与算法">
                            数据结构与算法
                        </a>
                        
                        
                        
                        <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" title="设计模式">
                            设计模式
                        </a>
                        
                        
                        
                        <a href="/tags/%E9%A1%B9%E7%9B%AE" title="项目">
                            项目
                        </a>
                        
                        
                    </div>
                </section>
                

                
                
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">                  
                    
                    <li>
                        <a href="mailto:1424197205@qq.com">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		           
                    
                    
                    
                    

		            
                    
                    <li>
                        <a target="_blank" href="/#">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-weixin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    <li>
                        <a target="_blank" href="https://github.com/yiguan1573">
                            <span class="fa-stack fa-lg">
                                <i class="fas fa-circle fa-stack-2x"></i>
                                <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
		            
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
           
                   <li>
                       <a href='' rel="alternate" type="application/rss+xml" title="亿观的博客" >
                           <span class="fa-stack fa-lg">
                               <i class="fas fa-circle fa-stack-2x"></i>
                               <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                           </span>
                       </a>
                   </li>
            
             </ul>
		<p class="copyright text-muted">
                    Copyright &copy; 亿观的博客 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="100px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>






<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





</body>
</html>
